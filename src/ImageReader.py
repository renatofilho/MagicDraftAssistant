from PIL import Image
import pytesseract
import cv2 as cv
import numpy as np
import re
import tempfile
import os
import math

from PySide6.QtCore import QObject, Signal, QFile, QThread, QRect, QPoint, QSize, QStandardPaths
from Database import CardDB

class CardArea(object):
    # these values are based on resolution  3840x2160
    # TODO: modify it to support multiple resolutions
    TEMPLATE_X_OFFSET = 17
    TEMPLATE_Y_OFFSET = 485
    TITLE_LEFT_MARGIN = 28
    TITLE_TOP_MARGIN = 25
    TITLE_WIDTH = 262
    TITLE_HEIGHT = 31
    CARD_WIDTH = 369
    CARD_HEIGHT = 513
    def __init__(self, template_x, template_y):
        self._template_pos = (template_x, template_y)
        self._texts = []
        self._card_db = None
        self._top_left = QPoint(template_x - self.TEMPLATE_X_OFFSET, template_y - self.TEMPLATE_Y_OFFSET)


    def appendText(self, text):
        self._texts.append(text)


    def titleArea(self):
        return QRect(self._top_left + QPoint(self.TITLE_LEFT_MARGIN, self.TITLE_TOP_MARGIN), QSize(self.TITLE_WIDTH, self.TITLE_HEIGHT))


    def rect(self):
        return QRect(self._top_left,  QSize(self.CARD_WIDTH, self.CARD_HEIGHT))


    def hasDatabase(self):
        return not self._card_db is None


    def valueFromDatabase(self, field_name):
        if not self._card_db:
            return None

        return self._card_db.get(field_name).value()



# we do OCR on thread since this could block UI
class TextExtractTask(QThread):
    progress = Signal(float)

    def __init__(self, card_set, img, parent = None):
        super().__init__(parent)
        self._source_img = img
        self._result = []
        self._card_set = card_set
        self._template = None
        self._cache_dir = os.path.join(QStandardPaths.writableLocation(QStandardPaths.AppLocalDataLocation), "cache")


    def _cacheFilename(self, img):
        h = cv.img_hash.pHash(img) # 8-byte hash
        ph = int.from_bytes(h.tobytes(), byteorder='big', signed=False)
        return os.path.join(self._cache_dir, f"text_{ph}.txt")


    def _extractFromCache(self, img):
        cached_file = self._cacheFilename(img)
        if not os.path.isfile(cached_file):
            return None

        with open(cached_file, encoding='utf8') as f:
            return f.readline()

        return None


    def _writeToCache(self, img, txt):
        cached_file = self._cacheFilename(img)
        with open(cached_file, "w", encoding='utf8') as f:
            f.write(txt)


    def _extractText(self, img, idx):
        txt = self._extractFromCache(img)
        if txt:
            print("Loaded from cache:", txt)
            return txt

        # write image on disk
        temp_file = os.path.join(tempfile.gettempdir(), f"text{idx}.png")
        cv.imwrite(temp_file,img)

        pil = Image.open(temp_file)
        custom_config = r'--oem 3 --psm 7'
        txt = pytesseract.image_to_string(pil, config=custom_config)

        # remove some garbage that could be generated by mana symbols or card borders
        txt = "".join([x for x in txt if x.isprintable()]).strip()
        txt = re.sub(r'[§)(\@‘\d{|:]', ' ', txt).strip()

        words = list(filter(None, txt.split(' ')))
        if not words:
            return ""

        # in some cases it could produce invalid words at beggining and the end
        # so we remove any word with less than 3 letters from begginin or the end
        if len(words[0]) < 3:
            words = words[1:]

        while(words):
            if len(words[-1]) < 3:
                words = words[0:-1]
            else:
                break

        txt =  " ".join(words).strip()
        self._writeToCache(img, txt)
        return txt


    def _findCards(img, template):
        img = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
        template = cv.cvtColor(template, cv.COLOR_BGR2GRAY)

        # Store width and height of template in w and h
        w, h = template.shape[::-1]

        # Perform match operations.
        res = cv.matchTemplate(img, template, cv.TM_CCOEFF_NORMED)

        # Specify a threshold
        threshold = 0.94

        # Store the coordinates of matched area in a numpy array
        loc = np.where(res >= threshold)
        found = []

        def ignoreClosePoints(pt):
            # filter points that are close
            # opencv identify the same mark more than once
            for p in found:
                dist = math.hypot(pt[0] - p[0], pt[1] - p[1])
                if dist < 50:
                    return False
            found.append(pt)
            return True

        result =  filter(lambda pt: ignoreClosePoints(pt), zip(*loc[::-1]))
        return (img, list(result))


    def run(self):
        self._result = []

        if not self._template:
            try:
                self._template = TextExtractTask._findTemplate(self._source_img)
            except FileNotFoundError:
                print("Abort")
                return

        img, loc = TextExtractTask._findCards(self._source_img, self._template)

        # keep track of the progress
        p = 0.0

        max_p = len(loc)

        # Draw a rectangle around the matched region.
        for pt in loc:

            p = p + 1.0
            self.progress.emit(p/max_p)

            if self.isInterruptionRequested():
                return

            card = CardArea(pt[0], pt[1])
            textArea = card.titleArea()
            x = textArea.left()
            y = textArea.top()
            x1 = x + textArea.width()
            y1 = y + textArea.height()

            i = len(self._result)

            crop_img = img[y:y1, x:x1]
            txt = self._extractText(crop_img, i)
            if txt:
                card.appendText(txt)

            self._result.append(card)
            if self.isInterruptionRequested():
                return


    # find a template based on image size
    def _findTemplate(img):
        h, w, _ = img.shape
        template_filename = f"template_{w}_{h}.png"
        print("Looking for template:", template_filename)

        app_dir = os.path.dirname(os.path.realpath(__file__))
        template_filename = os.path.join(app_dir, "icons", template_filename)
        print("Loading template:", template_filename)
        if not os.path.isfile(template_filename):
            raise FileNotFoundError()

        return cv.imread(template_filename)


class ImageReader(QObject):
    started = Signal()
    finished = Signal()
    progress = Signal(float)

    def __init__(self, db, parent = None):
        super().__init__(parent)
        self._data = []
        self._db = db
        self._current_thread = None
        self._calibration = []


    def reload(self, card_set, filename):
        self.started.emit()
        self.progress.emit(0.0)

        if QFile.exists(filename):
            self._rgb = cv.imread(filename)
        else:
            print(f"Source image does not exists: {filename}")

        if self._current_thread:
            self._current_thread.requestInterruption()
            self._current_thread.wait()
            del self._current_thread

        self._current_thread = TextExtractTask(card_set, self._rgb, self)
        self._current_thread.progress.connect(self.progress)
        self._current_thread.finished.connect(self._onThreadFinished)
        self._current_thread.start()


    def _onThreadFinished(self):
        card_db = CardDB(self._db)
        card_set = self._current_thread._card_set
        for data in self._current_thread._result:
            for text in data._texts:
                data._card_db = self._findCard(card_db, card_set, text)
                if data._card_db:
                    break

        self._data = self._current_thread._result
        self.progress.emit(1.0)
        self.finished.emit()


    def _findCard(self, card_db, card_set, name):
        if not name:
            return None
        if len(name) < 5:
            return None
        card_name = name.replace("’", "'")
        row = card_db.select("set_ = ? AND name LIKE ?", (card_set, f"%{card_name}%"))
        if not row:
            return None

        return row[0]


    def cards(self):
        return self._data


    def cardsId(self):
        ids = []
        for data in self._data:
            if data._card_db:
                ids.append(data._card_db["id"].value())

        return ids
